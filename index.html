<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D 互動聖誕樹 (MediaPipe + Three.js)</title>
    
    <!-- 引入 Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <!-- 引入 MediaPipe Hands -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Times New Roman', serif; /* 改用更有節日氣氛的字體 */
        }

        /* 全螢幕 Canvas */
        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        /* Webcam 預覽視窗 - 完全隱藏但保留功能 */
        .input_video_container {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 1px;
            height: 1px;
            opacity: 0;
            pointer-events: none;
            overflow: hidden;
        }

        .input_video {
            width: 1px;
            height: 1px;
        }

        /* 載入畫面 */
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ffd700;
            font-size: 24px;
            z-index: 20;
            pointer-events: none;
            text-align: center;
            text-shadow: 0 0 10px #ffaa00;
            font-family: sans-serif;
        }

        /* 標題文字 */
        #title-text {
            position: absolute;
            bottom: 10%; /* 改到底部，避免遮擋樹頂 */
            width: 100%;
            text-align: center;
            color: #ffd700;
            font-size: 4rem;
            letter-spacing: 8px;
            text-shadow: 0 0 15px #ffaa00, 0 0 30px #ff4500;
            z-index: 5;
            pointer-events: none;
            opacity: 0;
            animation: fadeIn 3s forwards 1s;
        }

        @keyframes fadeIn {
            to { opacity: 1; }
        }
    </style>
</head>
<body>

    <!-- 載入提示 -->
    <div id="loading">正在裝飾聖誕樹...<br><span style="font-size:16px">請允許使用攝影機以進行手勢控制</span></div>

    <!-- 標題 -->
    <div id="title-text">MERRY CHRISTMAS</div>

    <!-- Three.js 容器 -->
    <div id="canvas-container"></div>

    <!-- Webcam 隱藏元素 (MediaPipe 用) -->
    <div class="input_video_container">
        <video class="input_video"></video>
    </div>

    <script>
        // ==========================================
        // 1. 全域變數與設定
        // ==========================================
        // 使用網上 Placeholder 圖片供 GitHub Demo 使用
        const imgPaths = [
            'https://placehold.co/600x400/red/white?text=Merry',
            'https://placehold.co/600x400/green/white?text=Christmas',
            'https://placehold.co/600x400/blue/white?text=2025',
            'https://placehold.co/600x400/gold/white?text=Happy',
            'https://placehold.co/600x400/purple/white?text=Holidays'
        ];
        
        // 互動狀態
        let state = {
            rotationSpeed: 0.005,      // 基礎自轉速度
            targetRotationSpeed: 0.005,
            expansion: 0,              // 0 = 緊密, 1 = 完全展開
            targetExpansion: 0,
            handDetected: false
        };

        // 輪播控制變數
        let carouselIndex = 0;
        let lastSwitchTime = 0;
        const switchInterval = 5000; // 改慢：5秒換一張，讓用家有時間欣賞

        // Three.js 核心變數
        let scene, camera, renderer;
        let treeGroup, particleSystem;
        let photoCards = [];
        let snowSystem;
        let clock = new THREE.Clock();

        // ==========================================
        // 2. Three.js 初始化與場景建立
        // ==========================================
        function initThree() {
            const container = document.getElementById('canvas-container');

            // 場景
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x050510, 0.002); // 深色霧氣營造氛圍

            // 相機 - 拉遠一點以容納整棵樹
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 10, 70); // Z軸拉遠
            camera.lookAt(0, 5, 0);

            // 渲染器
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            // 開啟陰影貼圖 (雖然粒子不產生陰影，但對禮物盒有用)
            renderer.shadowMap.enabled = true;
            container.appendChild(renderer.domElement);

            // 燈光 - 增強燈光效果 (更亮)
            const ambientLight = new THREE.AmbientLight(0x888888); // 大幅調亮環境光
            scene.add(ambientLight);
            
            const pointLight = new THREE.PointLight(0xffaa00, 3.0, 100); // 增強點光源強度
            pointLight.position.set(20, 30, 20);
            scene.add(pointLight);

            const blueLight = new THREE.PointLight(0x4488ff, 2.0, 100); // 增強藍光補光
            blueLight.position.set(-20, 10, 20);
            scene.add(blueLight);

            // 額外的正面補光，確保樹夠亮
            const frontLight = new THREE.DirectionalLight(0xffffff, 1.5);
            frontLight.position.set(0, 10, 50);
            scene.add(frontLight);

            // 建立物件
            createStarField();
            createLushTree(); // 改用新的茂盛樹函數
            createPhotoCards();
            createSnow();

            // 監聽視窗大小改變
            window.addEventListener('resize', onWindowResize, false);
        }

        // 建立星空背景
        function createStarField() {
            const geometry = new THREE.BufferGeometry();
            const vertices = [];
            for (let i = 0; i < 2000; i++) {
                vertices.push(
                    THREE.MathUtils.randFloatSpread(200),
                    THREE.MathUtils.randFloatSpread(200),
                    THREE.MathUtils.randFloatSpread(200)
                );
            }
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            const material = new THREE.PointsMaterial({ color: 0xffffff, size: 0.5, transparent: true, opacity: 0.8 });
            const stars = new THREE.Points(geometry, material);
            scene.add(stars);
        }

        // 建立茂盛的粒子樹 (Lush Tree)
        function createLushTree() {
            treeGroup = new THREE.Group();
            scene.add(treeGroup);

            // 1. 樹葉粒子 (綠色主體) - 調亮顏色
            const leafCount = 8000; 
            const leafGeo = new THREE.BufferGeometry();
            const leafPos = [];
            const leafCols = [];
            const leafSizes = [];
            const leafBase = [];

            const colorGreenDark = new THREE.Color(0x008800); // 提亮深綠
            const colorGreenLight = new THREE.Color(0x44cc44); // 提亮淺綠
            const colorGold = new THREE.Color(0xffff00); // 更亮的金色

            for (let i = 0; i < leafCount; i++) {
                // 圓錐體分佈
                const h = Math.random() * 40; // 高度 0-40
                const hNorm = h / 40;
                const maxRadius = (1 - hNorm) * 15; // 底部半徑15
                
                // 隨機角度和半徑 (集中在表面，但也填充內部)
                const angle = Math.random() * Math.PI * 2;
                // 半徑分佈：平方根分佈讓粒子更均勻，或者偏向外層
                const r = Math.sqrt(Math.random()) * maxRadius; 
                
                // 螺旋擾動 (讓樹看起來有旋轉生長的紋理)
                const spiralOffset = h * 0.5;
                const finalAngle = angle + spiralOffset;

                const x = Math.cos(finalAngle) * r;
                const z = Math.sin(finalAngle) * r;
                const y = h - 20; // 垂直置中

                leafPos.push(x, y, z);
                leafBase.push({x, y, z, angle: finalAngle, radius: r, height: y});

                // 顏色混合
                let color;
                if (Math.random() > 0.8) {
                    // 20% 機率是金色/亮點
                    color = colorGold;
                    leafSizes.push(Math.random() * 0.6 + 0.4);
                } else {
                    // 80% 是綠色漸層
                    color = colorGreenDark.clone().lerp(colorGreenLight, Math.random());
                    leafSizes.push(Math.random() * 0.8 + 0.2);
                }
                leafCols.push(color.r, color.g, color.b);
            }

            leafGeo.setAttribute('position', new THREE.Float32BufferAttribute(leafPos, 3));
            leafGeo.setAttribute('color', new THREE.Float32BufferAttribute(leafCols, 3));
            leafGeo.setAttribute('size', new THREE.Float32BufferAttribute(leafSizes, 1));

            const leafMat = new THREE.PointsMaterial({
                size: 0.5,
                vertexColors: true,
                map: getTexture(),
                blending: THREE.NormalBlending, // 改回 NormalBlending 讓綠色更實心
                depthWrite: false,
                transparent: true,
                opacity: 0.8
            });

            particleSystem = new THREE.Points(leafGeo, leafMat);
            particleSystem.userData = { basePositions: leafBase };
            treeGroup.add(particleSystem);

            // 2. 裝飾禮物盒 (Gifts)
            const boxGeo = new THREE.BoxGeometry(1.5, 1.5, 1.5);
            const giftColors = [0xff0000, 0x0000ff, 0xffd700, 0xffffff];
            
            for(let i=0; i<15; i++) {
                const color = giftColors[Math.floor(Math.random() * giftColors.length)];
                const mat = new THREE.MeshStandardMaterial({ 
                    color: color, 
                    roughness: 0.3, 
                    metalness: 0.7 
                });
                const mesh = new THREE.Mesh(boxGeo, mat);
                
                // 隨機掛在樹上
                const h = Math.random() * 30; // 不要在太高的地方
                const hNorm = h / 40;
                const r = (1 - hNorm) * 15 + 1; // 稍微突出表面
                const angle = Math.random() * Math.PI * 2;
                
                mesh.position.set(
                    Math.cos(angle) * r,
                    h - 20,
                    Math.sin(angle) * r
                );
                
                // 隨機旋轉
                mesh.rotation.set(Math.random(), Math.random(), Math.random());
                
                // 綁定數據用於展開動畫
                mesh.userData = {
                    baseRadius: r,
                    baseAngle: angle,
                    baseHeight: h - 20,
                    isGift: true
                };
                
                treeGroup.add(mesh);
            }

            // 3. 頂部大星星
            const starShape = new THREE.Shape();
            const points = 5;
            for (let i = 0; i < points * 2; i++) {
                const l = i % 2 == 1 ? 1 : 2.5;
                const a = i / points * Math.PI;
                starShape.lineTo(Math.cos(a) * l, Math.sin(a) * l);
            }
            const starGeo = new THREE.ExtrudeGeometry(starShape, { depth: 0.5, bevelEnabled: false });
            const starMat = new THREE.MeshBasicMaterial({ color: 0xffff00 });
            const starMesh = new THREE.Mesh(starGeo, starMat);
            starMesh.position.set(0, 21, 0); // 樹頂
            starMesh.scale.set(1.5, 1.5, 1.5);
            treeGroup.add(starMesh);
            
            // 星星發光光暈
            const glowGeo = new THREE.PlaneGeometry(10, 10);
            const glowMat = new THREE.MeshBasicMaterial({
                map: getTexture(),
                color: 0xffd700,
                transparent: true,
                opacity: 0.5,
                blending: THREE.AdditiveBlending,
                side: THREE.DoubleSide,
                depthWrite: false
            });
            const glowMesh = new THREE.Mesh(glowGeo, glowMat);
            glowMesh.position.set(0, 21, 0);
            treeGroup.add(glowMesh);
            
            // 讓光暈永遠面向相機
            glowMesh.userData = { isBillboard: true };
        }

        // 產生粒子紋理 - 優化光暈效果
        function getTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 32;
            canvas.height = 32;
            const context = canvas.getContext('2d');
            // 中心亮，邊緣柔和
            const gradient = context.createRadialGradient(16, 16, 0, 16, 16, 16);
            gradient.addColorStop(0, 'rgba(255,255,255,1)');
            gradient.addColorStop(0.4, 'rgba(255,255,255,0.3)');
            gradient.addColorStop(1, 'rgba(0,0,0,0)');
            context.fillStyle = gradient;
            context.fillRect(0, 0, 32, 32);
            const texture = new THREE.Texture(canvas);
            texture.needsUpdate = true;
            return texture;
        }

        // 建立照片卡片
        function createPhotoCards() {
            const loader = new THREE.TextureLoader();
            const cardGeometry = new THREE.PlaneGeometry(4, 3); // 4:3 比例
            
            // 發光邊框材質 (放在照片後面)
            const borderGeometry = new THREE.PlaneGeometry(4.4, 3.4);
            const borderMaterial = new THREE.MeshBasicMaterial({ color: 0xffd700, side: THREE.DoubleSide });

            imgPaths.forEach((path, index) => {
                // 計算位置：均勻分佈在螺旋上
                const t = (index + 1) / (imgPaths.length + 1); // 避免放在最底或最頂
                const height = t * 25; 
                const angle = t * 30; 
                const radius = (1 - t) * 10 + 2; // 稍微比樹突出

                const group = new THREE.Group();
                
                // 載入圖片
                loader.load(path, (texture) => {
                    const material = new THREE.MeshBasicMaterial({ 
                        map: texture, 
                        side: THREE.DoubleSide 
                    });
                    const card = new THREE.Mesh(cardGeometry, material);
                    group.add(card);
                }, undefined, (err) => {
                    // 如果圖片載入失敗，顯示替代色塊
                    console.warn(`無法載入圖片: ${path}`);
                    const material = new THREE.MeshBasicMaterial({ color: 0xcc0000 });
                    const card = new THREE.Mesh(cardGeometry, material);
                    group.add(card);
                });

                // 邊框
                const border = new THREE.Mesh(borderGeometry, borderMaterial);
                border.position.z = -0.1; // 放在照片後面
                group.add(border);

                // 儲存初始位置參數
                group.userData = {
                    baseAngle: angle,
                    baseHeight: height,
                    baseRadius: radius
                };

                // 初始位置
                group.position.set(
                    Math.cos(angle) * radius,
                    height,
                    Math.sin(angle) * radius
                );

                treeGroup.add(group);
                photoCards.push(group);
            });
        }

        // 建立落雪效果
        function createSnow() {
            const geometry = new THREE.BufferGeometry();
            const vertices = [];
            for (let i = 0; i < 1000; i++) {
                vertices.push(
                    THREE.MathUtils.randFloatSpread(100),
                    THREE.MathUtils.randFloat(0, 50),
                    THREE.MathUtils.randFloatSpread(100)
                );
            }
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            const material = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 0.3,
                map: getTexture(),
                transparent: true,
                opacity: 0.6,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            snowSystem = new THREE.Points(geometry, material);
            scene.add(snowSystem);
        }

        // ==========================================
        // 3. MediaPipe Hands 設定
        // ==========================================
        function initMediaPipe() {
            const videoElement = document.getElementsByClassName('input_video')[0];
            
            const hands = new Hands({locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
            }});

            hands.setOptions({
                maxNumHands: 2, // 改為偵測雙手，避免一隻手放下時干擾另一隻手
                modelComplexity: 1,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });

            hands.onResults(onHandsResults);

            const cameraUtils = new Camera(videoElement, {
                onFrame: async () => {
                    await hands.send({image: videoElement});
                },
                width: 320,
                height: 240
            });
            
            cameraUtils.start()
                .then(() => {
                    document.getElementById('loading').style.display = 'none';
                })
                .catch(err => {
                    console.error("Webcam error:", err);
                    document.getElementById('loading').innerHTML = "無法啟動攝影機<br>請檢查權限";
                });
        }

        function onHandsResults(results) {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                state.handDetected = true;
                
                // 邏輯升級：支援雙手，但只聽「舉得比較高」那一隻手的指令
                // 這樣當你換手時，只要把新那隻手舉高，舊那隻手放下，就會自動切換
                
                let activeHandIndex = 0;
                let minY = 1.0; // Y 越小代表越上面

                // 找出最高的那隻手
                results.multiHandLandmarks.forEach((landmarks, index) => {
                    const wristY = landmarks[0].y;
                    if (wristY < minY) {
                        minY = wristY;
                        activeHandIndex = index;
                    }
                });

                const landmarks = results.multiHandLandmarks[activeHandIndex];
                
                // 1. 旋轉控制 (X軸) - 增加靈敏度
                const x = landmarks[9].x; 
                // 增加死區 (Deadzone) 避免手在中間時亂動
                // 增加增益 (Gain) 讓轉動更快
                let rotationInput = 0.5 - x;
                if (Math.abs(rotationInput) < 0.05) rotationInput = 0; // 死區
                state.targetRotationSpeed = rotationInput * 0.3; // 提高速度係數

                // 2. 展開控制 (握拳 vs 張開) - 改用手指尖與手腕的距離判斷
                // 0: 手腕, 5,9,13,17: 指根, 8,12,16,20: 指尖
                const wrist = landmarks[0];
                const tips = [8, 12, 16, 20];
                let avgDist = 0;
                
                tips.forEach(idx => {
                    const tip = landmarks[idx];
                    // 計算歐幾里得距離 (簡化版，只看 x, y)
                    const d = Math.sqrt(Math.pow(tip.x - wrist.x, 2) + Math.pow(tip.y - wrist.y, 2));
                    avgDist += d;
                });
                avgDist /= tips.length;

                // 經驗值：握拳時 avgDist 約 < 0.15，張開時 > 0.3
                // 正規化到 0-1
                let openFactor = (avgDist - 0.15) * 4; // 0.15 -> 0, 0.4 -> 1
                state.targetExpansion = Math.max(0, Math.min(1, openFactor));

            } else {
                state.handDetected = false;
                state.targetRotationSpeed = 0.005;
                state.targetExpansion = 0;
            }
        }

        // ==========================================
        // 4. 動畫循環
        // ==========================================
        function animate() {
            requestAnimationFrame(animate);

            // 平滑過渡 (Lerp)
            state.rotationSpeed += (state.targetRotationSpeed - state.rotationSpeed) * 0.1;
            state.expansion += (state.targetExpansion - state.expansion) * 0.05;

            // 1. 旋轉樹木
            // 當照片放大展示時 (expansion > 0.5)，大幅減慢樹的旋轉，避免眼花
            let currentRotationSpeed = state.rotationSpeed;
            if (state.expansion > 0.5) {
                currentRotationSpeed *= 0.2;
            }

            if (treeGroup) {
                treeGroup.rotation.y += currentRotationSpeed;
            }

            // 2. 樹木本體隨手勢「爆開」 (Explosion Effect)
            if (particleSystem) {
                const positions = particleSystem.geometry.attributes.position.array;
                const sizes = particleSystem.geometry.attributes.size.array;
                const baseData = particleSystem.userData.basePositions;

                for (let i = 0; i < baseData.length; i++) {
                    const data = baseData[i];
                    
                    // 爆開邏輯：
                    // 1. 半徑大幅擴張
                    const expansionMultiplier = 1 + (state.expansion * 4.0); // 擴張 5 倍
                    const currentRadius = data.radius * expansionMultiplier;
                    
                    // 2. 高度隨機擴散 (讓粒子看起來像炸開)
                    // 使用 sin/cos 讓擴散有點規律但又混亂
                    const heightScatter = Math.sin(i) * state.expansion * 20;
                    
                    const x = Math.cos(data.angle) * currentRadius;
                    const z = Math.sin(data.angle) * currentRadius;
                    const y = data.height + heightScatter;

                    positions[i * 3] = x;
                    positions[i * 3 + 1] = y;
                    positions[i * 3 + 2] = z;

                    // 閃爍效果保持
                    if (Math.random() > 0.95) {
                        sizes[i] = Math.random() * 0.6 + 0.2;
                    }
                }
                particleSystem.geometry.attributes.position.needsUpdate = true;
                particleSystem.geometry.attributes.size.needsUpdate = true;
            }

            // 3. 更新照片位置 - 一次性全部展示 (Gallery Mode)
            photoCards.forEach((card, index) => {
                const data = card.userData;
                
                let targetScale = 0;
                let targetPos = new THREE.Vector3(0, data.baseHeight, 0); 

                if (state.expansion > 0.1) {
                    // --- 全部展示模式 ---
                    // 將照片排列在鏡頭前方的弧形位置，確保全部可見
                    
                    const total = photoCards.length;
                    // 計算 X 軸分佈：從 -30 到 30
                    const range = 50;
                    const step = range / (total - 1);
                    const xPos = -range / 2 + index * step;
                    
                    // 高度錯落分佈，避免太整齊
                    // 偶數高一點，奇數低一點
                    const yPos = 10 + (index % 2 === 0 ? 5 : -5);
                    
                    // Z 軸：放在樹的前面 (Z=40)，相機在 Z=70
                    const zPos = 40;

                    targetPos.set(xPos, yPos, zPos);
                    targetScale = 3.5; // 大小適中，讓畫面能容納所有照片
                    card.renderOrder = 999;
                } else {
                    // --- 隱藏模式 ---
                    // 縮回樹中心
                    targetPos.set(0, data.baseHeight, 0);
                    targetScale = 0;
                }

                // 動畫平滑過渡
                card.position.lerp(targetPos, 0.08);
                
                const currentScale = card.scale.x;
                const newScale = THREE.MathUtils.lerp(currentScale, targetScale, 0.08);
                card.scale.setScalar(newScale);

                card.lookAt(camera.position);
                
                // 深度測試控制
                if (newScale > 1) {
                    card.children.forEach(c => {
                        if(c.material) c.material.depthTest = false;
                    });
                } else {
                    card.children.forEach(c => {
                        if(c.material) c.material.depthTest = true;
                    });
                }
            });

            // 4. 禮物盒隨樹木爆開
            treeGroup.children.forEach(child => {
                if (child.userData.isGift) {
                    const data = child.userData;
                    // 跟隨粒子的擴張比例
                    const expansionMultiplier = 1 + (state.expansion * 4.0);
                    const currentRadius = data.baseRadius * expansionMultiplier;
                    
                    child.position.x = Math.cos(data.baseAngle) * currentRadius;
                    child.position.z = Math.sin(data.baseAngle) * currentRadius;
                    // 禮物盒也稍微上下散開
                    child.position.y = data.baseHeight + (Math.sin(child.id) * state.expansion * 10);
                    
                    child.rotation.y += 0.01;
                    child.rotation.x += 0.005;
                }
                if (child.userData.isBillboard) {
                    child.lookAt(camera.position);
                }
            });

            // 5. 落雪動畫
            if (snowSystem) {
                const positions = snowSystem.geometry.attributes.position.array;
                for (let i = 1; i < positions.length; i += 3) {
                    positions[i] -= 0.1; // 往下掉
                    if (positions[i] < -20) { // 調整邊界
                        positions[i] = 50; // 重置到頂部
                    }
                }
                snowSystem.geometry.attributes.position.needsUpdate = true;
                // 雪花整體微微旋轉
                snowSystem.rotation.y -= 0.001;
            }

            // 5. 閃爍效果 (Twinkle)
            if (particleSystem) {
                const sizes = particleSystem.geometry.attributes.size.array;
                for(let i=0; i<sizes.length; i++) {
                    // 隨機挑選粒子改變大小，製造閃爍感
                    if (Math.random() > 0.9) {
                        sizes[i] = Math.random() * 0.4 + 0.1;
                    }
                }
                particleSystem.geometry.attributes.size.needsUpdate = true;
            }

            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // ==========================================
        // 啟動
        // ==========================================
        initThree();
        initMediaPipe();
        animate();

    </script>
</body>
</html>
